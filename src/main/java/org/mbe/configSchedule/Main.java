package org.mbe.configSchedule;

import com.google.ortools.Loader;
import com.opencsv.CSVWriter;
import de.vill.model.FeatureModel;
import org.mbe.configSchedule.generator.SPGenerator;
import org.mbe.configSchedule.parser.FMReader;
import org.mbe.configSchedule.parser.UVLReader;
import org.mbe.configSchedule.solver.ConfigurationSolver;
import org.mbe.configSchedule.solver.ProblemSolver;
import org.mbe.configSchedule.util.*;
import org.xml.sax.SAXException;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPathExpressionException;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Duration;
import java.time.Instant;
import java.util.*;

// =======================================================================
// Basierend auf dem Jobshop-Problem-Beispiel von Google OR-Tools
// https://developers.google.com/optimization/scheduling/job_shop?hl=de
// 07.08.2024
// ========================================================================

public class Main {

    public static void main(String[] args) throws ParserConfigurationException, IOException, SAXException, XPathExpressionException, ClassNotFoundException {
        Loader.loadNativeLibraries();
        PathPreferences prefs = new PathPreferences();

        // 0 = search for feasible solution, 1 = search for optimal solution
        int mode = 1;

        if (args.length == 12 || args.length == 2 || args.length == 3 || args.length == 4) {
            switch (args[0]) {

                // Generate a problem via the programm
                case "generate":
                    // Parse some arguments to integers
                    int[] intParameter = new int[10];
                    for (int i = 1; i < args.length - 1; i++) {
                        intParameter[i - 1] = Integer.parseInt(args[i]);
                    }
                    SPGenerator spgenerator = new SPGenerator();
                    spgenerator.generateProblem(intParameter[0], intParameter[1], intParameter[2], intParameter[3], intParameter[4], intParameter[5],
                            intParameter[6], intParameter[7], intParameter[8], intParameter[9], args[11]);

                    System.out.println("Problem saved as " + args[11] + ".uvl \n" +
                            "To solve use: solve [o or f] " + args[11] + ".uvl");
                    break;

                // Solve a problem
                case "solve":
                    // set mode (search for feasible or optimal solution?)
                    switch (args[1]) {
                        case "o":
                            mode = 1;
                            break;
                        case "f":
                            mode = 0;
                            break;
                        default:
                            System.out.println("Undefinded argument " + args[1] + "\n" +
                                    "Please use \"o\" to search for an optimal schedule or \"f\" to search for a feasible schedule");
                            break;
                    }

                    if (args.length == 3) {
                        // For problems generated by the program
                        if (args[2].endsWith(".txt") || args[2].endsWith(".uvl")) {
                            Instant readStart = Instant.now();
                            SchedulingProblem sp = ReadProblemUVL(args[2]);
                            Instant readEnd = Instant.now();

                            PrintProblem(sp);

                            Instant solveStart = Instant.now();
                            ProblemSolver problemSolver = new ProblemSolver(sp);
                            SolverReturn sr;
                            if (mode == 0) {
                                sr = problemSolver.getFirstSolution();
                            } else {
                                sr = problemSolver.getBestSolution();
                            }

                            Instant solveEnd = Instant.now();

                            long readTime = Duration.between(readStart, readEnd).toMillis();
                            long solveTime = Duration.between(solveStart, solveEnd).toMillis();
                            long combinedTime = readTime + solveTime;

                            if (sr != null) {
                                PrintSolution(sr);
                                System.out.println("Read Time: " + readTime + "ms, Solve Time: " + solveTime + "ms, Combined: " + combinedTime + "ms");
                                WriteCSV(sr, mode, args[2]);
                            } else {
                                System.out.println("No solution found");
                                System.out.println("Read Time: " + readTime + "ms, Solve Time: " + solveTime + "ms, Combined: " + combinedTime + "ms");
                            }
                        }
                        // For problems in the form of an xml-file
                        else if (args[2].endsWith(".xml")) {
                            Instant readStart = Instant.now();
                            SchedulingProblem sp = FMReader.readFM(args[2]);
                            Instant readEnd = Instant.now();

                            PrintProblem(sp);

                            Instant solveStart = Instant.now();
                            ProblemSolver problemSolver = new ProblemSolver(sp);
                            SolverReturn sr;
                            if (mode == 0) {
                                sr = problemSolver.getFirstSolution();
                            } else {
                                sr = problemSolver.getBestSolution();
                            }

                            Instant solveEnd = Instant.now();

                            long readTime = Duration.between(readStart, readEnd).toMillis();
                            long solveTime = Duration.between(solveStart, solveEnd).toMillis();
                            long combinedTime = readTime + solveTime;

                            if (sr != null) {
                                PrintSolution(sr);
                                System.out.println("Read Time: " + readTime + "ms, Solve Time: " + solveTime + "ms, Combined: " + combinedTime + "ms");
                                WriteCSV(sr, mode, args[2]);
                            } else {
                                System.out.println("No solution found");
                                System.out.println("Read Time: " + readTime + "ms, Solve Time: " + solveTime + "ms, Combined: " + combinedTime + "ms");
                            }
                        }
                    // For searching over the set of instances
                    } else if (args.length == 4) {
                        String modelPath = args[2];
                        SchedulingProblem sp = FMReader.readFM(modelPath);
                        PrintProblem(sp);
                        ConfigurationSolverReturn csr;
                        if (mode == 0) {
                            csr = ConfigurationSolver.getFirst(args[3], modelPath);
                        } else {
                            csr = ConfigurationSolver.getBest(args[3], modelPath);
                        }

                        if (csr != null && csr.isHasSolution()) {
                            PrintSolution(csr.getSolverReturn());
                            System.out.println("Found solution in iteration " + csr.getIteration() + "\n" +
                                    "Read time: " + csr.getReadTime() + "ms, Solve time: " + csr.getTimeSolve() + "ms, Combined: " + csr.getNeededTime() + "ms");
                            WriteCSV(csr.getSolverReturn(), mode, args[2]);
                        } else {
                            System.out.println("No solution found");
                            System.out.println("Searched in " + (csr.getSearchedConfigs() - 1) + " configurations \n" +
                                    "Read time: " + csr.getReadTime() + "ms, Solve time: " + csr.getTimeSolve() + "ms, Combined: " + csr.getNeededTime() + "ms");
                        }
                    }
                    break;

                // Working with the path preferences
                case "solutionpath":
                    prefs.setSolutionSavePath(args[1]);
                    System.out.printf("Path for saving solutions problems set to %s", args[1]);
                    break;
                case "problempath":
                    prefs.setProblemSavePath(args[1]);
                    System.out.printf("Path for saving generated problems set to %s", args[1]);
                    break;
                case "get":
                    if (args[1].equals("solutionpath")) {
                        System.out.println(prefs.getSolutionSavePath());
                    } else if (args[1].equals("problempath")) {
                        System.out.println(prefs.getProblemSavePath());
                    }
                    break;
                case "delete":
                    if(args[1].equals("solutionpath")) {
                        prefs.removeSolutionSavePath();
                        System.out.println("Deleted path for saving solutions");
                    } else if(args[1].equals("problempath")) {
                        prefs.removeProblemSavePath();
                        System.out.println("Deleted path for saving problems");
                    }
                    break;
                default:
                    System.out.println("Undefined command " + args[0] + "\n" +
                            "Use \"generate\" or \"solve\"");
            }
        } else {
            System.out.println("Wrong command or wrong amount of arguments \n" +
                    "To generate a problem: generate <jobCount> <taskCount> <durationOutlier> " +
                    "<machineCount> <optionalCount> <altCount> <altGroupCount> <deadline> <name> \n" +
                    "To solve a problem: solve [o or f] <name>");
        }

    }


    /**
     * Deprecated. Reads problems generated by the program, serialized into a txt-file
     * @param name Name of the problem
     * @return {@link SchedulingProblem} the problem from the file
     * @throws IOException
     * @throws ClassNotFoundException
     */
    public static SchedulingProblem ReadProblemGen(String name) throws IOException, ClassNotFoundException {
        //FileInputStream fIn = new FileInputStream("src/main/probleme/" + name);
        PathPreferences prefs = new PathPreferences();
        String path = prefs.getProblemSavePath();
        FileInputStream fIn = new FileInputStream(path + name);
        ObjectInputStream oIn = new ObjectInputStream(fIn);
        SchedulingProblem sp = (SchedulingProblem) oIn.readObject();
        oIn.close();

        return sp;
    }

    /**
     * Reads a problem from a file in, which contents are formatted as an uvl.
     * @param name          The name of the problem
     * @return              A {@link SchedulingProblem} with the properties of the input-file
     * @throws IOException
     */
    public static SchedulingProblem ReadProblemUVL(String name) throws IOException {
        Path path = Path.of("");
        Path filePath = Path.of("");
        if(name.contains("/")) {
            filePath = Path.of(name);
        } else {
            PathPreferences prefs = new PathPreferences();
            path = Path.of(prefs.getProblemSavePath());
            filePath = path.resolve(name);
        }

        System.out.println("\n" + name + "\n");
        FeatureModel fm = UVLReader.read(filePath);
        SchedulingProblem sp = new SchedulingProblem(fm);
        return sp;
    }

    /**
     * Prints a problem
     * @param sp    The {@link SchedulingProblem} to be printed
     */
    public static void PrintProblem(SchedulingProblem sp) {
        System.out.println("*********************** \n" +
                "Scheduling problem:");
        System.out.println("Deadline: " + sp.getDeadline());
        int index = 0;
        for (List<Task> job : sp.getJobs()) {
            System.out.println("Job " + index + ": ");
            for (Task task : job) {
                System.out.print(task.getName() + ", d: [" + task.getDuration()[0] + "," + task.getDuration()[1] + "], m: " + task.getMachine().getName() + ", o: " + task.isOptional()
                        + ", e: " + task.getExcludeTasks().toString() + ", d: ");
                for (Map.Entry<Integer, List<Task>> item : task.getDurationCons().entrySet()) {
                    System.out.print("[" + item.getKey() + "; ");
                    for (Task t : item.getValue()) {
                        System.out.print(t.getName() + ",");
                    }
                    System.out.print("], ");
                }
                System.out.println();
            }
            index++;
        }

        System.out.println("\n*********************** \n");
    }

    /**
     * Prints a solution
     * @param sr    The {@link SolverReturn} to be printed
     */
    public static void PrintSolution(SolverReturn sr) {
        System.out.println("Solution:");
        System.out.printf(sr.getOutput() + "\n");
        System.out.println("Schedule is " + sr.getStatus() + ", takes " + sr.getTime());
    }

    /**
     * Converts a solution to a {@link List} of String-Arrays, which can be used to save the solution as a CSV-file.
     * @param sr    The solution in the form of a {@link SolverReturn}, which should be converted
     * @return      A {@link List} of {@link Arrays} of type {@link String}
     */
    public static List<String[]> ConvertSRToStrings(SolverReturn sr) {
        Map<Machine, List<AssignedTask>> assignedJobs = new HashMap<>(sr.getAssignedJobs());
        List<String[]> resultString = new ArrayList<>();

        for (Machine m : assignedJobs.keySet()) {
            String[] mLine = new String[assignedJobs.get(m).size() + 1];
            String[] iLine = new String[assignedJobs.get(m).size() + 1];
            mLine[0] = m.getName();
            iLine[0] = m.getName() + "Intervals";

            int index = 1;
            for (AssignedTask t : assignedJobs.get(m)) {
                if (t.isActive()) {
                    mLine[index] = t.getName();
                    iLine[index] = t.getStart() + "," + (t.getStart() + t.getDuration());
                    index++;
                }
            }

            resultString.add(mLine);
            resultString.add(iLine);
        }


        return resultString;
    }

    /**
     * Saves a solution to a CSV-file
     * @param sr            The solution in the form of a {@link SolverReturn}
     * @param mode          An {@link Integer} indicating the mode (feasible/optimal) of the search
     * @param ProblemPath   The path of the corresponding problem
     * @throws IOException
     */
    public static void WriteCSV(SolverReturn sr, int mode, String ProblemPath) throws IOException {
        List<String[]> data = ConvertSRToStrings(sr);
        String fileName = ReadProblemName(ProblemPath);

        if (mode == 0) {
            fileName = fileName + "-feasible";
        } else if (mode == 1) {
            fileName = fileName + "-optimum";
        }

        PathPreferences prefs = new PathPreferences();

        Path path = Path.of(prefs.getSolutionSavePath());
        if(!Files.exists(path)) {
            Files.createDirectories(path);
        }

        Path filePath = path.resolve(fileName);

        File file = new File(String.valueOf(filePath));
        FileWriter outputFile = new FileWriter(file);
        CSVWriter csvWriter = new CSVWriter(outputFile);

        for (String[] line : data) {
            csvWriter.writeNext(line);
        }

        csvWriter.close();

    }

    /**
     * Extracts the name of a problem from its file path
     * @param path  The path to the problem file
     * @return      The name of the problem
     */
    public static String ReadProblemName(String path) {
        String[] subStrings = path.split("/");
        String s = subStrings[subStrings.length - 1];

        String[] subStrings2 = s.split("\\.");
        String s2 = subStrings2[0];

        return s2;
    }
}