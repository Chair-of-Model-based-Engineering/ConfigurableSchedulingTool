package org.mbe.configSchedule.generator;

import org.mbe.configSchedule.util.Machine;
import org.mbe.configSchedule.util.SchedulingProblem;
import org.mbe.configSchedule.util.Task;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.stream.IntStream;

import static java.lang.Math.floor;

public class SPGenerator {

    public void generateProblem(int jobCount, int taskCount,
                                             int durationOutlierCount, int machineCount, int optionalCount,
                                             int altCount, int altGroupCount, int deadline, int durationConstraints, int maxDurationRequires, String name) throws IOException {
        List<List<Task>> jobs = new ArrayList<>();
        List<Machine> machines = new ArrayList<>();

        // Used to create duration-constraints
        // From a mandatory task with a variable duration, can one or more require constraints originate from one duration
        // To make sure that there are no require constraints from the same duration leading to multiple tasks in the same
        // alternative task group, the tasks in an alternative task group (and optional tasks) are saved in an array,
        // so that a require constraint can lead to only one task in that group
        List<Task[]> optionalTasks = new ArrayList<>();
        List<Task> mandatoryTasksWithVarDuration = new ArrayList<>();

        Random random = new Random();

        if(jobCount > taskCount) {
            System.out.println("Please enter more tasks than jobs");
        }

        // Fill the necessary lists (jobs and machines)
        createMachines(machineCount, machines);
        createStandardJobs(taskCount, jobCount, machineCount, durationOutlierCount, machines, jobs, mandatoryTasksWithVarDuration);
        createOptionalTasks(optionalCount, machineCount, machines, jobs, optionalTasks);
        createAlternativeTasks(altCount, altGroupCount, machineCount, machines, jobs, optionalTasks);
        createDurationConstraints(optionalTasks, mandatoryTasksWithVarDuration, durationConstraints, maxDurationRequires);

        // Create a SchedulingProblem from the beforehand created lists
        SchedulingProblem sp = new SchedulingProblem(jobs, machines, deadline);

        //String fileOutputString = "src/main/probleme/" + name + ".txt";
        String fileOutputString = "/home/max/Schreibtisch/Generierte_Probleme/" + name + ".txt";
        FileOutputStream fOut = new FileOutputStream(fileOutputString);
        ObjectOutputStream oOut = new ObjectOutputStream(fOut);

        oOut.writeObject(sp);
        oOut.flush();
        oOut.close();

        //return new SchedulingProblem(jobs, machines, deadline);
    }

    /**
     * Creates the machines for the problem genreated by the Problem Generator
     * @param machineCount The number of machines (to be created)
     * @param machines List of machines
     */
    private static void createMachines(int machineCount, List<Machine> machines) {
        int machineID = 1;
        for(int i = 0; i < machineCount; i++) {
            Machine machine = new Machine("m" + machineID, false);
            machineID++;
            machines.add(machine);
        }
    }

    /**
     * Creates the standard jobs for the problem generated by the Problem Generator
     * @param taskCount The total number of tasks (to be created)
     * @param jobCount The number of jobs (to be created)
     * @param machineCount The number of machines
     * @param durationOutlierCount The number of tasks with a duration that lies outside the "normal" range
     * @param machines The number of machines
     * @param jobs List of jobs
     * @param mandatoryTasksWithVarDuration List of mandatory tasks that have a variable duration
     */
    private static void createStandardJobs(int taskCount, int jobCount, int machineCount, int durationOutlierCount,
                                          List<Machine> machines, List<List<Task>> jobs, List<Task> mandatoryTasksWithVarDuration) {
        Random random = new Random();

        double tasksPerJobD = taskCount / jobCount;
        int tasksPerJob = (int) floor(tasksPerJobD);
        int restTasks = taskCount % tasksPerJob;
        int tasksInJob;

        boolean firstJob = true;
        int taskID = 1;

        for(int i = 0; i < jobCount; i++) {
            List<Task> job = new ArrayList<>();

            // Falls es der erste Job ist, sollen die überschüssigen Tasks in ihm sein
            if(firstJob) {
                tasksInJob = tasksPerJob + restTasks;
                firstJob = false;
            } else {
                tasksInJob = tasksPerJob;
            }

            for(int j = 0; j < tasksInJob; j++) {

                Task task = new Task();
                task.setName("p" + taskID);
                taskID++;
                task.setMachine(machines.get(random.nextInt(machineCount)));
                task.setDuration(new int[2]);

                // Wenn mehr durationOutlier übrig sind (oder so viele) wie noch zu erstellende Tasks gibt,
                // soll die Task auf jeden Fall ein Outlier sein
                if (((taskCount - taskID) == durationOutlierCount) && (durationOutlierCount > 0)){
                    // Soll es eine variable Dauer sein?
                    int variableDurationChance  = random.nextInt(2);
                    // 0 = Variable Dauer, 1 = feste Dauer
                    if(variableDurationChance == 0) {
                        // Zwischen 6 und 15
                        int dur1 = random.nextInt(10) + 6;
                        int dur2 = random.nextInt(10) + 6;
                        int[] duration = {dur1, dur2};
                        task.setDuration(duration);

                        // Task zu den mandatory Tasks hinzufügen für Duration Constraints
                        mandatoryTasksWithVarDuration.add(task);
                    } else {
                        int dur = random.nextInt(10) + 6;
                        int[] duration = {dur, dur};
                        task.setDuration(duration);
                    }
                    durationOutlierCount--;

                } else {
                    // Trotzdem noch die Chance ein Outlier zu werden
                    int outLierChance = random.nextInt(2);
                    // 0 = Outlier, 1 = Kein Outlier
                    if(outLierChance == 0 && durationOutlierCount > 0) {
                        // Soll es eine variable Dauer sein?
                        int variableDurationChance  = random.nextInt(2);
                        // 0 = Variable Dauer, 1 = feste Dauer
                        if(variableDurationChance == 0) {
                            // Zwischen 6 und 15
                            int dur1 = random.nextInt(10) + 6;
                            int dur2 = random.nextInt(10) + 6;
                            int[] duration = {dur1, dur2};
                            task.setDuration(duration);

                            mandatoryTasksWithVarDuration.add(task);
                        } else {
                            int dur = random.nextInt(10) + 6;
                            int[] duration = {dur, dur};
                            task.setDuration(duration);
                        }
                        durationOutlierCount--;

                        // Kein Outlier
                    } else {
                        // Soll es eine variable Dauer sein?
                        int variableDurationChance  = random.nextInt(2);
                        // 0 = Variable Dauer, 1 = feste Dauer
                        if(variableDurationChance == 0) {
                            // Zwischen 1 und 5
                            int dur1 = random.nextInt(5) + 1;
                            int dur2 = random.nextInt(5) + 1;
                            int[] duration = {dur1, dur2};
                            task.setDuration(duration);

                            mandatoryTasksWithVarDuration.add(task);
                        } else {
                            int dur = random.nextInt(5) + 1;
                            int[] duration = {dur, dur};
                            task.setDuration(duration);
                        }
                    }
                }

                task.setOptional(false);
                job.add(task);
            }
            jobs.add(job);
        }
    }

    /**
     * Creates the optional tasks for the problem generated by the Problem Generator
     * @param optionalCount The number of optional tasks to be created
     * @param machineCount the number of machines
     * @param machines List of machines
     * @param jobs List of jobs
     * @param optionalTasks List of optionalTasks
     */
    private static void createOptionalTasks(int optionalCount, int machineCount, List<Machine> machines, List<List<Task>> jobs,
                                            List<Task[]> optionalTasks) {

        Random random = new Random();

        int taskID = 1;

        // Create optional tasks
        for(int i = 0; i < optionalCount; i++) {
            List<Task> job = new ArrayList<>();
            Task task = new Task();

            task.setName("po" + taskID);
            taskID++;
            task.setMachine(machines.get(random.nextInt(machineCount)));
            task.setOptional(true);
            task.setDuration(new int[2]);

            // Randomly choose if task has a variable duration
            int varDurationChance = random.nextInt(2);

            // 0 = Variable, 1 = static
            if(varDurationChance == 0) {
                // Between 1 and 5
                int dur1 = random.nextInt(5) + 1;
                int dur2 = random.nextInt(5) + 1;
                int[] duration = {dur1, dur2};
                task.setDuration(duration);
            } else {
                // Not variable
                int dur = random.nextInt(5) + 1;
                int[] duration = {dur, dur};
                task.setDuration(duration);
            }

            // Add to optional tasks
            Task[] taskArr = {task};
            optionalTasks.add(taskArr);

            job.add(task);
            jobs.add(job);
        }
    }

    /**
     * Creates the alternative task groups for the problem generated by the Problem Generator
     * @param altCount The total number of tasks belonging to alternative task groups (to be created)
     * @param altGroupCount The number of alternative task groups (to be created)
     * @param machineCount The number of machines
     * @param machines List of machines
     * @param jobs List of jobs
     * @param optionalTasks List of optional tasks
     */
    private static void createAlternativeTasks(int altCount, int altGroupCount, int machineCount, List<Machine> machines,
                                               List<List<Task>> jobs, List<Task[]> optionalTasks) {
        // Check if there even are alternative tasks to be created
        if(altCount > 0 && altGroupCount > 0) {
            Random random = new Random();

            // Calculate how many tasks beling in one group
            // If there are e.g. 5 tasks and 2 groups -> g1 = (1,2,3), g2 = (4,5)
            double tasksPerGroupD = altCount / altGroupCount;
            int tasksPerGroup = (int) floor(tasksPerGroupD);
            int restTasksAlt = altCount % tasksPerGroup;
            int tasksInGroup;

            boolean firstGroup = true;

            int taskID = 1;
            for (int i = 0; i < altGroupCount; i++) {
                // If it's the first group that is created, then it should include the surplus of tasks
                if (firstGroup) {
                    tasksInGroup = tasksPerGroup + restTasksAlt;
                    firstGroup = false;
                } else {
                    tasksInGroup = tasksPerGroup;
                }

                // Task-array that, at the end, contains all the tasks belonging to one alternative task group
                Task[] group = new Task[tasksInGroup];

                // Create tasks for the group
                for (int j = 0; j < tasksInGroup; j++) {
                    List<Task> job = new ArrayList<>();
                    Task task = new Task();
                    task.setName("pa" + taskID);
                    taskID++;
                    task.setMachine(machines.get(random.nextInt(machineCount)));
                    task.setDuration(new int[2]);

                    // Randomly choose if the task has a variable duration
                    int variableDurationChance = random.nextInt(2);
                    // 0 = Variable, 1 = static
                    if (variableDurationChance == 0) {
                        // Between 1 and 5
                        int dur1 = random.nextInt(5) + 1;
                        int dur2 = random.nextInt(5) + 1;
                        int[] duration = {dur1, dur2};
                        task.setDuration(duration);
                    } else {
                        int dur = random.nextInt(5) + 1;
                        int[] duration = {dur, dur};
                        task.setDuration(duration);
                    }

                    task.setOptional(true);
                    task.setExcludeTasks(new ArrayList<>());
                    group[j] = task;

                    // An alternative task is its own job
                    job.add(task);
                    jobs.add(job);
                }

                // Add the alternative task group to the optionalTasks
                optionalTasks.add(group);

                // Every task in the group has a list with the other tasks of the group
                // These are the tasks that the task exludes
                // If there is the group (1,2,3) -> ExcludeTasks(1) = {2,3}
                for (int j = 0; j < group.length; j++) {
                    List<String> list = group[j].getExcludeTasks();

                    for (int k = 0; k < group.length; k++) {
                        if (j != k) {
                            list.add(group[k].getName());
                        }
                    }
                }
            }
        }
    }

    /**
     * Creates the duration constraints for the problem generated by the Problem Generator
     * @param optionalTasks List with arrays of optional tasks. Optional Tasks are arrays with one task, alternative task groups are arrays with multiple tasks
     * @param mandatoryTasksWithVarDuration List with mandatory tasks that have a variable duration
     * @param durationConstraints int that determines the number of durations that are part of a duration constraint
     * @param maxDurationRequires int that determines the number of constraints originating from one duration
     */
    private static void createDurationConstraints(List<Task[]> optionalTasks, List<Task> mandatoryTasksWithVarDuration,
                                                  int durationConstraints, int maxDurationRequires) {
        Random random = new Random();

        // Check if there are enough mandatory Tasks for the number of durationConstraints
        if(durationConstraints > mandatoryTasksWithVarDuration.size()) {
            System.out.printf("Not enough mandatory tasks with variable durations for durationConstraints %d, set to %d.%n",
                    durationConstraints, mandatoryTasksWithVarDuration.size());
            durationConstraints = mandatoryTasksWithVarDuration.size();
        }

        // Check if there are enough optional Tasks for the max. amount
        // of Duration-Constraints originating from one task
        if(maxDurationRequires > optionalTasks.size()) {
            System.out.printf("Not enough optional/ alternative tasks for maxDurationRequires %d, set to %d.%n",
                    maxDurationRequires, optionalTasks.size());
            maxDurationRequires = optionalTasks.size();

        }

        if(!optionalTasks.isEmpty()) {
            List<Integer> mandIndeces = IntStream.range(0, mandatoryTasksWithVarDuration.size() + 1).boxed().toList();
            // Iterate over mandatory tasks with variable duration
            // If there are 3 durationConstraints, then the first 3 tasks will have duration constraints
            for (int i = 0; i < durationConstraints; i++) {
                Task task = mandatoryTasksWithVarDuration.get(i);

                // Choose which duration value is part of the constraint
                int minDuration = task.getDuration()[0];
                int maxDuration = task.getDuration()[1];
                int durationForConstraint = random.nextInt((maxDuration + 1) - minDuration) + minDuration;

                List<Task> requiredTasks = new ArrayList<>();

                // List with an Index for every optional task/ alternative task group
                // If there are 3 optional tasks, then the list is {0,1,2}
                List<Integer> optionalIndices = new ArrayList<>();
                for(int j = 0; j < optionalTasks.size(); j++) {
                    optionalIndices.add(j);
                }

                System.out.printf("Erster Eintrag in optionalIndices: %d, letzer Eintrag: %d \n",
                        optionalIndices.get(0), optionalIndices.get(optionalIndices.size()-1));
                for (int j = 0; j < maxDurationRequires; j++) {
                    // Randomly choose one of the indeces in optionalIndices - Via that index we can
                    // choose an optional task group from optionalTasks
                    // Remove Index from optionalIndices, so that that index is not chosen twice
                    int taskGroupIndex = optionalIndices.get(random.nextInt(optionalIndices.size()));
                    optionalIndices.remove(optionalIndices.indexOf(taskGroupIndex));
                    Task[] taskGroup = optionalTasks.get(taskGroupIndex);

                    // Randomly chooses one of the tasks in the group to be
                    // the required task for the constraint
                    int taskIndex = random.nextInt(taskGroup.length);
                    Task requiredTask = taskGroup[taskIndex];
                    requiredTasks.add(requiredTask);
                }

                task.addDurationCon(durationForConstraint, requiredTasks);
            }
        }
    }
}
